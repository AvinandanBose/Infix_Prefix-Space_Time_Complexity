<h1 align="Center">𝑰𝒏𝒇𝒊𝒙 𝑻𝒐 𝑷𝒓𝒆𝒇𝒊𝒙 𝑪𝒐𝒏𝒗𝒆𝒓𝒔𝒊𝒐𝒏</h1>
<ul>
  
  <h3>𝑨𝒔 𝒖𝒔𝒖𝒔𝒂𝒍 , 𝒑𝒖𝒔𝒉 , 𝒑𝒐𝒑 𝒆𝒕𝒄. 𝒘𝒊𝒍𝒍 𝒃𝒆 𝒔𝒂𝒎𝒆 𝒂𝒔 𝒖𝒔𝒖𝒂𝒍 𝒂𝒔 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒊𝒏 𝑷𝒐𝒔𝒕𝒇𝒊𝒙 𝒆𝒒𝒖𝒂𝒕𝒊𝒐𝒏. 𝑻𝒉𝒂𝒕 𝒊𝒔 𝒔𝒕𝒂𝒄𝒌 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏.  </h3>
<h3>  𝑴𝒐𝒓𝒆 𝒐𝒓 𝒍𝒆𝒔𝒔 𝒂𝒑𝒑𝒓𝒐𝒂𝒄𝒉 𝒓𝒆𝒎𝒂𝒊𝒏𝒔 𝒕𝒉𝒆 𝒔𝒂𝒎𝒆 𝒖𝒏𝒍𝒆𝒔𝒔
𝒘𝒆 𝒄𝒐𝒎𝒆 𝒕𝒐 𝒑𝒓𝒆𝒇𝒊𝒙 𝒄𝒐𝒏𝒗𝒆𝒓𝒔𝒊𝒐𝒏.</h3>
  
  <h3> 𝑳𝒆𝒕 𝒊𝒏𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒃𝒆 ∶ (𝒂 + 𝒃)</h3>
 <h3> 𝒊𝒇 𝒘𝒆 𝒔𝒆𝒆 𝒕𝒉𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏: 𝒂𝒃 +</h3>
<h3>  𝑩𝒖𝒕 𝒇𝒐𝒓 𝒑𝒓𝒆𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒘𝒆 𝒉𝒂𝒗𝒆 ∶ +𝒂𝒃</h3>
  
<h3 align="Center"><ins>𝑵𝒐𝒘 𝒍𝒐𝒐𝒌 𝒂𝒕 𝒕𝒉𝒆 𝒂𝒑𝒑𝒓𝒐𝒂𝒄𝒉 </h3>
  
 <ul>
   
 <h3><li>𝑺𝒐 𝒘𝒆 𝒉𝒂𝒗𝒆:(𝒂 + 𝒃)</li></h3>
  
 <h3><li> 𝑵𝒐𝒘 𝒊𝒇 𝒘𝒆 𝒔𝒄𝒂𝒏 𝒇𝒓𝒐𝒎 𝒍𝒂𝒔𝒕 𝒕𝒐 𝒇𝒊𝒓𝒔𝒕 𝒘𝒆 𝒈𝒆𝒕 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏:𝒃𝒂 +</li></h3>
 <h3><li> 𝒔𝒂𝒚 𝒂[𝟎] = 𝒃, 𝒂[𝟏] = 𝒂, 𝒂𝒏𝒅 𝒂[𝟐] = +</li></h3>
   
<h3><li>𝑵𝒐𝒘,𝒍𝒆𝒕𝒔 𝒔𝒘𝒂𝒑 𝒂[𝟐] 𝒂𝒏𝒅 𝒂[𝟎].</li></h3>
   
<ul>
  
  
<h3><li> 𝒂[𝟐] = 𝒕𝒆𝒎𝒑(𝒂 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆) = +</li></h3>
<h3><li>𝒂[𝟐] = 𝒂[𝟎] = 𝒃</li></h3>
<h3><li>𝒂[𝟎] = 𝒕𝒆𝒎𝒑 = +.</li></h3>
<h3><li>𝑵𝒐𝒘 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒉𝒂𝒗𝒆 + 𝒂𝒃. </li></h3>
  
</ul> 

</ul> 
 
  
<h2></h2>  
<h2 align="Center">𝑪𝒐𝒏𝒗𝒆𝒓𝒔𝒊𝒐𝒏</h2> 
  
<ul>
  
<h2>𝟏. 𝑳𝒆𝒕𝒔 𝒕𝒂𝒌𝒆 𝒂 𝒃𝒊𝒈𝒈𝒆𝒓 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏: (𝒂 + 𝒃) ∗ (𝒄 + 𝒅)/𝒆</h2>
  
![Screenshot (624)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/2e35d5a1-02c7-471f-bd11-5982a169bae4)
  
<h3><li>𝒍𝒆𝒏 𝒐𝒓 𝒍𝒆𝒏𝒈𝒕𝒉 𝒐𝒇 𝒕𝒉𝒆 𝒂𝒓𝒓𝒂𝒚 𝒐𝒇 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓𝒔 = 𝟏𝟑.</li></h3>
<h3><li>𝑨𝒏𝒅 𝒂𝒓𝒓𝒂𝒚 𝒑𝒓𝒐𝒄𝒆𝒆𝒅𝒔 𝒇𝒓𝒐𝒎 𝟎 𝒕𝒐 𝟏𝟐 𝒂𝒏𝒅 𝒂𝒔 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒕𝒐 𝒔𝒄𝒂𝒏 𝒇𝒓𝒐𝒎 𝒍𝒂𝒔𝒕 𝒕𝒐 𝒇𝒊𝒓𝒔𝒕 , 𝒉𝒆𝒏𝒄𝒆 𝒊 = 𝟏𝟐 𝒂𝒏𝒅 𝒋 = 𝟎.  </li></h3>
  
![Screenshot (625)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/b0a342b7-b535-451f-9637-c821775da37e)

<h2> </h2> 
<h2>𝟐.𝑳𝒂𝒔𝒕 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒊𝒔 `𝒆` </h2> 
<h3><li>𝑨𝒔 𝒕𝒉𝒆 𝒍𝒂𝒔𝒕 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒊𝒔 𝒆 , 𝒉𝒆𝒏𝒄𝒆 𝒊𝒔𝑶𝒑𝒆𝒓𝒂𝒏𝒅(𝒊𝒏𝒇𝒊𝒙[𝟏𝟐]) == 𝟏
𝒊𝒔 𝒕𝒓𝒖𝒆 , 𝒉𝒆𝒏𝒄𝒆 𝒑𝒓𝒆𝒇𝒊𝒙[𝟎] = 𝒆.𝒋 = 𝟎 + 𝟏 = 𝟏 𝒂𝒏𝒅 𝒊 = 𝟏𝟐 − 𝟏 =
𝟏𝟏.</li></h3>  
  
<h3><li>𝑯𝒆𝒏𝒄𝒆 𝒕𝒊𝒍𝒍 𝒏𝒐𝒘 𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒘𝒆 𝒉𝒂𝒗𝒆 = 𝒆 . </li></h3>  

<h2> </h2> 
<h2>𝟑.𝑵𝒐𝒘 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 '/' </h2>   
<h3><li>  𝒊𝒏𝒇𝒊𝒙[𝟏𝟏] =/ 𝒊𝒔 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 , 𝒉𝒆𝒏𝒄𝒆 𝒊𝒔𝑶𝒑𝒆𝒓𝒂𝒏𝒅()
𝒘𝒊𝒍𝒍 𝒓𝒆𝒕𝒖𝒓𝒏 𝟎.</li></h3> 
<h3><li>𝑯𝒆𝒏𝒄𝒆 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒎𝒐𝒗𝒆 𝒕𝒐 𝒆𝒍𝒔𝒆 𝒑𝒂𝒓𝒕,</li></h3> 
  
  ![Screenshot (626)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/90670dd3-f714-465b-89f6-728c6aa5acbc)
  
<h3><li> 𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝒊] = 𝒊𝒏𝒇𝒊𝒙[𝟏𝟏] =/= 𝟐 > 𝒑𝒓𝒆(𝒕𝒐𝒑 = −𝟏)) 𝒊𝒔 𝒕𝒓𝒖𝒆.</li></h3>
<h3><li>𝑨𝒏𝒅 𝑺𝒕𝒂𝒄𝒌 𝒊𝒔 𝑬𝒎𝒑𝒕𝒚 , 𝒉𝒆𝒏𝒄𝒆, 𝒑𝒖𝒔𝒉(/) , 𝒕𝒐𝒑 = −𝟏 + 𝟏 = 𝟎. </li></h3> 
  
![Screenshot (627)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/2d60645e-2c11-47cf-a27e-f4fde11b6415)
  
<h3><li>𝒊 = 𝟏𝟏 − 𝟏 = 𝟏𝟎.</li></h3> 
 
<h2> </h2>  
<h2>𝟒.𝑵𝒐𝒘 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 ')' </h2> 
  
![Screenshot (629)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/698bec7c-a2e5-49c5-a82a-ba97b163117e)
  
  
<h3><li>𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝒊] = 𝒊𝒏𝒇𝒊𝒙[𝟏𝟎] = `)` ) = 𝟎 > 𝒑𝒓𝒆(𝒔[𝒕𝒐𝒑] = 𝒔[𝟎] = `/`) = 𝟐) 𝒊𝒔 𝒇𝒂𝒍𝒔𝒆. </li></h3> 
<h3><li>𝑨𝒏𝒅 ,𝒊𝒔𝑬𝒎𝒑𝒕𝒚(𝒔𝒕)𝒊𝒔 𝒂𝒍𝒔𝒐 𝒇𝒂𝒍𝒔𝒆.  </li></h3> 
<h3><li>𝑩𝒖𝒕,𝒊𝒏𝒇𝒊𝒙[𝟏𝟎] = `)` , 𝒉𝒆𝒏𝒄𝒆 ∶ 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒑𝒖𝒔𝒉 𝒊𝒕 𝒕𝒐 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌. </li></h3> 
<h3><li> 𝒕𝒐𝒑 = 𝟎 + 𝟏 = 𝟏.  </li></h3> 

![Screenshot (630)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/08a55b69-5f34-436e-99ba-71517f102ea7)

<h3><li>𝒊 = 𝟏𝟎 − 𝟏 = 𝟗.</li></h3> 
  
  
<h2> </h2> 
<h2>𝟓.𝑵𝒐𝒘 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒐𝒑𝒆𝒓𝒂𝒏𝒅 '𝒅' </h2>   
  
<h3><li>𝑵𝒐𝒘 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒊𝒏𝒇𝒊𝒙[𝟗] = 𝒅 𝒘𝒉𝒊𝒄𝒉 𝒊𝒔 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒏𝒅 , 𝒉𝒆𝒏𝒄𝒆 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒓𝒆𝒕𝒖𝒓𝒏 𝟏. </li></h3>   
  
![Screenshot (631)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/258506c0-7651-4517-8b6d-5e3b372e7785)
  

<h3><li>  𝒑𝒓𝒆𝒇𝒊𝒙[𝒋] = 𝒑𝒓𝒆𝒇𝒊𝒙[𝟏] = 𝒅. </li></h3>  
<h3><li> 𝒋 = 𝒋 + 𝟏 = 𝟏 + 𝟏 = 𝟐 </li></h3>  
<h3><li> 𝒊 = 𝒊 − 𝟏 = 𝟗 − 𝟏 = 𝟖.</li></h3> 
  
<h3><li>𝑯𝒆𝒏𝒄𝒆 𝒕𝒊𝒍𝒍 𝒏𝒐𝒘 𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒘𝒆 𝒉𝒂𝒗𝒆 = 𝒆𝒅  </li></h3>
  
  
<h2> </h2>  
<h2>𝟔.𝑵𝒐𝒘 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 ` + `</h2>
  
<h3><li>  𝑵𝒐𝒘 𝒊𝒏𝒇𝒊𝒙[𝟖] = +, 𝒉𝒆𝒏𝒄𝒆 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒈𝒆𝒕 𝒂𝒈𝒂𝒊𝒏 𝒑𝒖𝒔𝒉𝒆𝒅 𝒊𝒏𝒕𝒐 𝒕𝒉𝒆
𝒔𝒕𝒂𝒄𝒌.</li></h3>
  
  ![Screenshot (632)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/d8a1f53d-55a1-4d8e-8278-20d27aa64daf)

  
  
<h3><li>𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝒊]) = 𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝟖]) = 𝒑𝒓𝒆(` + `) = 𝟏
> 𝒑𝒓𝒆(𝒔[𝒕𝒐𝒑]) = 𝒑𝒓𝒆(𝒔[𝟏]) = 𝒑𝒓𝒆(`)`) = 𝟎 𝒘𝒉𝒊𝒄𝒉 𝒊𝒔 𝒕𝒓𝒖𝒆.</li></h3>
  
<h3><li>𝑻𝒉𝒐𝒖𝒈𝒉 𝒊𝒔𝑬𝒎𝒑𝒕𝒚(𝒔𝒕)𝒂𝒏𝒅 𝒊𝒏𝒇𝒊𝒙[𝒊] = `)` 𝒅𝒐𝒆𝒔𝒏𝒐𝒕 𝒎𝒂𝒕𝒄𝒉
𝑩𝒖𝒕 𝒂𝒔 𝒊𝒕 𝒊𝒔 𝑶𝑹 𝒓𝒆𝒍𝒂𝒕𝒊𝒐𝒏 ,𝒊𝒇 𝒔𝒕𝒂𝒕𝒆𝒎𝒆𝒏𝒕 𝒘𝒊𝒍𝒍 𝒓𝒖𝒏.</li></h3>
  
  
<h3><li>𝒑𝒖𝒔𝒉(` + `) 𝒂𝒏𝒅 𝒕𝒐𝒑 = 𝒕𝒐𝒑 + 𝟏 = 𝟏 + 𝟏 = 𝟐.</li></h3>
  
  
  ![Screenshot (633)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/571d0e11-4337-4feb-9e5c-9c22bd41976a)

  
 <h3><li> 𝒊 = 𝒊 − 𝟏 = 𝟖 − 𝟏 = 𝟕</li></h3>
  
 <h2> </h2>  
<h2>𝟕.𝑵𝒐𝒘 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒐𝒑𝒆𝒓𝒂𝒏𝒅 ` 𝒄 `</h2> 
  
  
<h3><li> 𝑵𝒐𝒘 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒊𝒏𝒇𝒊𝒙[𝟕] = 𝒄, 𝒘𝒉𝒊𝒄𝒉 𝒊𝒔 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒏𝒅 , 𝒉𝒆𝒏𝒄𝒆,</li></h3>
  
![Screenshot (634)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/845eeed4-f95b-4e6d-8baa-10af39a6d889)
 
<h3><li>  𝒑𝒓𝒆𝒇𝒊𝒙[𝒋] = 𝒑𝒓𝒆𝒇𝒊𝒙[𝟐] = 𝒊𝒏𝒇𝒊𝒙[𝟕] = 𝒄.</li></h3>
<h3><li>  𝒋 = 𝒋 + 𝟏 = 𝟐 + 𝟏 = 𝟑.</li></h3>
<h3><li>𝒊 = 𝟕 − 𝟏 = 𝟕 − 𝟏 = 𝟔.</li></h3>
  
<h3><li>  𝑯𝒆𝒏𝒄𝒆 𝒕𝒊𝒍𝒍 𝒏𝒐𝒘 𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒘𝒆 𝒉𝒂𝒗𝒆 = 𝒆𝒅𝒄</li></h3>
  
<h2> </h2>  
<h2> 𝟖. 𝑵𝒐𝒘 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒉𝒂𝒗𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 `(`</h2>
  
![Screenshot (635)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/9fe822b4-647c-406a-9479-ed0506b41d70)
  
  
<h3><li>𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝟔] = `(` ) = 𝟎 ≤ 𝒑𝒓𝒆(𝒔[𝟐] = ` + ` = 𝟏) 𝒂𝒏𝒅 𝒊𝒏𝒇𝒊𝒙[𝟔]= `(` , 𝒉𝒆𝒏𝒄𝒆:</li></h3>
<h3><li>  𝑯𝒆𝒏𝒄𝒆 𝒍𝒆𝒔𝒔 𝒕𝒉𝒂𝒏 `)` ,𝒊𝒕 𝒘𝒊𝒍𝒍 𝒑𝒐𝒑 𝒐𝒖𝒕 = ` + `.</li></h3>
  
<h3><li>  𝒑𝒓𝒆𝒇𝒊𝒙[𝟑] = 𝒑𝒐𝒑() = +</li></h3>
<h3><li>  𝒕𝒐𝒑 = 𝒕𝒐𝒑 − 𝟏 = 𝟐 − 𝟏 = 𝟏</li></h3>
<h3><li>  𝑯𝒆𝒏𝒄𝒆 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒊𝒔 𝒏𝒐𝒘: 𝒆𝒄𝒅 +</li></h3>
<h3><li>  𝒋 = 𝒋 + 𝟏 = 𝟑 + 𝟏 = 𝟒.</li></h3>
  
![Screenshot (636)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/1ab51388-5917-4292-a44d-ecb0b1eac316)
  
<h3><li>𝑵𝒐𝒘 , 𝒕𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒘𝒊𝒍𝒍 𝒑𝒐𝒑 𝒐𝒖𝒕 `)` . 𝑻𝒐𝒑 = 𝟏 − 𝟏 = 𝟎  </li></h3>
  
 ![Screenshot (637)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/d5e35f8e-04fb-4bd7-98d8-e8926024fe8f)
  
<h3><li>𝒊 = 𝒊 − 𝟏 = 𝟔 − 𝟏 = 𝟓.  </li></h3>
  
<h2> </h2>   
<h2> 𝟗. 𝑵𝒐𝒘 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒉𝒂𝒗𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 ` ∗ ` </h2>
  
<h3><li>𝑵𝒐𝒘 𝒊𝒏𝒇𝒊𝒙[𝒊] = 𝒊𝒏𝒇𝒊𝒙[𝟓] = ` ∗ ` . </li></h3>
  
 ![Screenshot (638)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/877a3f5f-d1c4-405c-a2ef-531117f3d6aa)
 
<h3><li>𝑯𝒆𝒏𝒄𝒆: 𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝟓] = ` ∗ `) = 𝟐 ≤ 𝒑𝒓𝒆(𝒔[𝒕𝒐𝒑] = 𝒔[𝟎] = `/` =
𝟐 ) 𝒊𝒔 𝒕𝒓𝒖𝒆 . </li></h3>
  
<h3><li>!𝒊𝒔𝑬𝒎𝒑𝒕𝒚(𝒔𝒕) 𝒊𝒔 𝒕𝒓𝒖𝒆 𝒂𝒏𝒅 𝒊𝒏𝒇𝒊𝒙[𝟓] 𝒊𝒔 𝒏𝒐𝒕 ( 𝒂𝒏𝒅 ) ,
𝒉𝒆𝒏𝒄𝒆 ∶  </li></h3>
  
<h3><li>𝒑𝒓𝒆𝒇𝒊𝒙[𝒋 = 𝟒 ] = 𝒑𝒐𝒑() =/  </li></h3>
  
<h3><li>𝒉𝒆𝒏𝒄𝒆 , 𝒕𝒐𝒑 = 𝒕𝒐𝒑 − 𝟏 = 𝟎 − 𝟏 = −𝟏,𝒊. 𝒆.𝑬𝒎𝒑𝒕𝒚.
𝒋 = 𝒋 + 𝟏 = 𝟒 + 𝟏 = 𝟓.  </li></h3>
  
![Screenshot (639)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/e3be1e9d-b0a3-4ac5-a93f-0f33dbceb597)
  
<h3><li>𝑵𝒐𝒘, 𝒑𝒖𝒔𝒉 (` ∗ `) 𝒕𝒐 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌. 𝑯𝒆𝒏𝒄𝒆 𝒕𝒐𝒑 𝒃𝒆𝒄𝒐𝒎𝒆𝒔: −𝟏 + 𝟏
= 𝟎.  </li></h3>
  
![Screenshot (640)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/deb11978-7d5b-4f71-aa44-f201b2de1161)
  
<h3><li>𝑻𝒉𝒆𝒓𝒆𝒇𝒐𝒓𝒆 , 𝒏𝒐𝒘 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏: 𝒆𝒅𝒄 +/
𝒊 = 𝒊 − 𝟏 = 𝟓 − 𝟏 = 𝟒.  </li></h3>
  
  
<h3><li>𝑵𝒐𝒘 𝒘𝒉𝒚 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒄𝒐𝒏𝒅𝒊𝒕𝒊𝒐𝒏 𝒍𝒊𝒌𝒆 ∶</li></h3>
  
![Screenshot (641)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/4411db72-641c-457b-a549-0bf6467321dd)
  
<h3> 𝒊𝒔 𝒅𝒊𝒔𝒄𝒖𝒔𝒔𝒆𝒅 𝒊𝒏  <a href="https://github.com/AvinandanBose/Infix_To_Postfix_Conversion">𝑷𝒐𝒔𝒕𝒇𝒊𝒙 𝑬𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</a></h3> 
  
<h2> </h2>  
<h2>𝟏𝟎.𝑵𝒆𝒙𝒕, 𝒘𝒆 𝒉𝒂𝒗𝒆 (𝒂 + 𝒃) 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</h2> 
  
<ul>  
  
<h3><li><ins>𝟏. 𝟏𝒔𝒕 𝒑𝒖𝒔𝒉(`)`) 𝒑𝒂𝒓𝒆𝒏𝒕𝒉𝒆𝒔𝒊𝒔. 𝑯𝒆𝒏𝒄𝒆 𝒕𝒐𝒑 = 𝟎 + 𝟏 = 𝟏.</ins></li></h3>
  
![Screenshot (642)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/84c2ce6f-7a13-4567-8370-a5746274db39)
  
![Screenshot (643)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/833bde6e-2db1-4287-a703-782f3bbc346d)
  
<h3>𝒊 = 𝒊 − 𝟏 = 𝟒 − 𝟏 = 𝟑.</h3>
  
<h3><li><ins>  𝟐. 𝑵𝒆𝒙𝒕 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒊𝒏𝒑𝒖𝒕 𝒕𝒉𝒆 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒊𝒏 𝒕𝒉𝒆 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</ins></li></h3>
 
![Screenshot (644)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/bd53f963-8fdc-40e2-a277-e59c08991a45)
 
<h3>𝒑𝒓𝒆𝒇𝒊𝒙[𝒋 = 𝟓] = 𝒊𝒏𝒇𝒊𝒙[𝒊 = 𝟑] = 𝒃. </h3>
<h3>  𝑻𝒉𝒆 𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏: 𝒆𝒅𝒄 +/𝒃</h3>
<h3>   𝒋 = 𝒋 + 𝟏 = 𝟓 + 𝟏 = 𝟔.</h3>
<h3>  𝒊 = 𝒊 − 𝟏 = 𝟑 − 𝟏 = 𝟐.</h3>
  
<h3><li><ins>𝟑.𝑾𝒆 𝒉𝒂𝒗𝒆 ` + ` 𝒂𝒏𝒅 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒑𝒖𝒔𝒉(` + `) 𝒊𝒏𝒕𝒐 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌. </ins></li></h3>
  
  ![Screenshot (646)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/e6dfc7df-6e49-47ce-8d63-f3b7720b0c50)
  
<h3>𝒊𝒔𝑬𝒎𝒑𝒕𝒚(𝒔𝒕)𝒊𝒔 𝒇𝒂𝒍𝒔𝒆 𝒂𝒏𝒅 𝒊𝒏𝒇𝒊𝒙[𝟐] = ` + ` 𝒏𝒐𝒕 `)`
𝒉𝒆𝒏𝒄𝒆 𝒇𝒂𝒍𝒔𝒆.𝑩𝒖𝒕,
𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝟐] = ` + `) = 𝟏 > 𝒑𝒓𝒆(𝒔[𝒕𝒐𝒑] = 𝒔[𝟏] = `)`)
= 𝟎 𝒊𝒔 𝒕𝒓𝒖𝒆.𝑯𝒆𝒏𝒄𝒆,
𝒑𝒖𝒔𝒉(𝒊𝒏𝒇𝒊𝒙[𝟐] = ` + `). 𝑯𝒆𝒏𝒄𝒆 𝒕𝒐𝒑 = 𝒕𝒐𝒑 + 𝟏 = 𝟏 + 𝟏 = 𝟐.</h3>
  
![Screenshot (647)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/e7718c34-8374-4bf3-9d02-cbc75d6757ee)
  
<h3><li><ins>𝟒.𝑾𝒆 𝒉𝒂𝒗𝒆 `𝒂` , 𝒑𝒖𝒕 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒊𝒏 𝒕𝒉𝒆 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.  </ins></li></h3>
 
 ![Screenshot (648)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/e0703c46-a121-4336-b37d-5541c6cfc37e) 
  
<h3>𝒑𝒓𝒆𝒇𝒊𝒙[𝟔] = 𝒊𝒏𝒇𝒊𝒙[𝟏] = 𝒂</h3>
<h3>𝒋 + += 𝒋 + 𝟏 = 𝟔 + 𝟏 = 𝟕</h3>

<h3>𝒊 − −= 𝒊 − 𝟏 = 𝟏 − 𝟏 = 𝟎</h3>
<h3>𝑯𝒆𝒏𝒄𝒆 , 𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 = 𝒆𝒅𝒄 +/𝒃𝒂  </h3>
  
  
<h3><li><ins>𝟓. 𝑵𝒐𝒘 𝒂𝒔 𝒘𝒆 𝒉𝒂𝒗𝒆 `(` , 𝒕𝒉𝒆 𝒕𝒉𝒊𝒏𝒈𝒔 𝒘𝒊𝒍𝒍 𝒈𝒆𝒕 𝒑𝒐𝒑 𝒐𝒖𝒕 𝒕𝒊𝒍𝒍 `)` .</ins></li></h3>
  
  ![Screenshot (649)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/9f506cb5-10fe-49ce-8257-188ad679a1dc)
  
<h3>𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝒊] = 𝒊𝒏𝒇𝒊𝒙[𝟎] = `(` ) = 𝟎 ≤ 𝒑𝒓𝒆(𝒔[𝒕𝒐𝒑] = 𝒔[𝟐] =
` + `) = 𝟏 𝒊𝒔 𝒕𝒓𝒖𝒆 𝒂𝒏𝒅 𝒊𝒏𝒇𝒊𝒙[𝟎] = `(` , 𝒉𝒆𝒏𝒄𝒆: </h3>
  
<h3>𝒑𝒓𝒆𝒇𝒊𝒙[𝟖] = 𝒑𝒐𝒑() = + 𝒂𝒏𝒅 𝒕𝒐𝒑 = 𝒕𝒐𝒑 − 𝟏 = 𝟐 − 𝟏 = 𝟏
𝒋 = 𝒋 + 𝟏 = 𝟕 + 𝟏 = 𝟖 .</h3>
  
![Screenshot (650)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/0f099840-b28b-483d-9442-e86581d236af)
  
<h3> 𝑵𝒐𝒘, 𝒑𝒐𝒑() = ), 𝒕𝒐𝒑 = 𝒕𝒐𝒑 − 𝟏 = 𝟏 − 𝟏 = 𝟎
𝒊 = 𝒊 − 𝟏 = 𝟎 − 𝟏 = −𝟏 </h3>
  
![Screenshot (651)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/8bcf0210-c8bf-4530-8a11-3ebca7f98762)
  
<h3>𝑯𝒆𝒏𝒄𝒆 𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 = 𝒆𝒅𝒄 +/𝒃𝒂 +</h3>
    
</ul>
  
</ul>
  
<h2> </h2>   
<h2> 𝟏𝟏.𝑷𝒐𝒑𝒑𝒊𝒏𝒈 𝒐𝒖𝒕 𝒘𝒉𝒂𝒕𝒆𝒗𝒆𝒓 𝒓𝒆𝒎𝒂𝒊𝒏𝒊𝒏𝒈 𝒊𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌.  </h2> 
  
<h3><li>𝑵𝒐𝒘 𝒘𝒉𝒂𝒕 𝒆𝒗𝒆𝒓 𝒊𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒋𝒖𝒔𝒕 𝒑𝒐𝒑() 𝒂𝒏𝒅 𝒊𝒏𝒑𝒖𝒕 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒊𝒏
𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏. </li></h3>
  
![Screenshot (652)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/d24144ea-d530-4685-a8ce-1deea39b9a25)
  
<h3><li>𝒑𝒓𝒆𝒇𝒊𝒙[𝟖] = 𝒑𝒐𝒑() =∗ , 𝒕𝒐𝒑 = 𝒕𝒐𝒑 − 𝟏 = 𝟎 − 𝟏 = −𝟏(𝒆𝒎𝒑𝒕𝒚). </li></h3>
  
![Screenshot (654)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/5717d8a4-2164-4300-b2a0-aeaf7858e552)
  
<h3><li>𝑯𝒆𝒏𝒄𝒆 𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 = 𝒆𝒅𝒄 +/𝒃𝒂 +∗  </li></h3>
<h3><li>𝒏𝒐𝒘 𝒋 = 𝒋 + 𝟏 = 𝟖 + 𝟏 = 𝟗.</li></h3>
<h3><li>  𝑨𝒏𝒅 𝒑𝒓𝒆𝒇𝒊𝒙[𝟗] = ′\𝟎′ 𝒊. 𝒆. 𝒆𝒏𝒅 𝒐𝒇 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓.</li></h3>

<h2> </h2>   
<h2 align="Center">  𝑵𝒐𝒘 𝒕𝒉𝒆 𝒎𝒐𝒔𝒕 𝒊𝒎𝒑𝒐𝒓𝒕𝒂𝒏𝒕 𝒑𝒂𝒓𝒕:</h2> 
  
<h3><li>𝑹𝒆𝒗𝒆𝒓𝒔𝒆 𝒐𝒓 𝑺𝒘𝒂𝒑 𝒕𝒉𝒆 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓𝒔 𝒇𝒓𝒐𝒎 𝒕𝒉𝒆 𝒍𝒂𝒔𝒕 𝒕𝒐 𝒇𝒊𝒓𝒔𝒕 𝒕𝒐
𝒈𝒆𝒕 𝒕𝒉𝒆 𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒊𝒏𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏. </li></h3>
  
  
![Screenshot (655)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/ddf27aa8-f7cd-4dfc-87dc-4bb812c3c434)
  
<h3><li>𝑺𝒕𝒂𝒓𝒕 = 𝟎 ,𝑬𝒏𝒅 = 𝟗 − 𝟏 = 𝟖.</li></h3>
  
<h3><li>𝑭𝒓𝒐𝒎 𝒔𝒕𝒂𝒓𝒕 𝒕𝒐 𝒆𝒏𝒅,𝒊𝒕 𝒘𝒊𝒍𝒍 𝒕𝒓𝒂𝒗𝒆𝒓𝒔𝒆 𝒇𝒐𝒓 𝒔𝒘𝒂𝒑𝒑𝒊𝒏𝒈.</li></h3>
<h3><li>𝒕𝒆𝒎𝒑 = 𝒑𝒓𝒆𝒇𝒊𝒙[𝟎] = 𝒆.</li></h3>
<h3><li>𝒑𝒓𝒆𝒇𝒊𝒙[𝟎] = 𝒑𝒓𝒆𝒇𝒊𝒙[𝟖] =∗.</li></h3>
<h3><li>𝒑𝒓𝒆𝒇𝒊𝒙[𝟖] = 𝒕𝒆𝒎𝒑 = 𝒆.  </li></h3>
<h3><li>𝑨𝒏𝒅 𝒕𝒉𝒊𝒔 𝒑𝒓𝒐𝒄𝒆𝒔𝒔 𝒄𝒐𝒏𝒕𝒊𝒏𝒖𝒆𝒔 𝒕𝒐 𝒈𝒆𝒕 𝒕𝒉𝒆 𝒑𝒓𝒆𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏:∗ +𝒂𝒃/+𝒄𝒅𝒆</li></h3>
  
 
</ul> 
  
  
 <h1></h1> 
<h1 align="Center">𝑨𝒍𝒈𝒐𝒓𝒊𝒕𝒉𝒎𝒊𝒄 𝑨𝒏𝒂𝒍𝒚𝒔𝒊𝒔</h1>
  

<h3>𝑨𝒇𝒕𝒆𝒓 𝒂𝒏𝒂𝒍𝒚𝒔𝒊𝒏𝒈 𝒕𝒉𝒆 𝒘𝒐𝒓𝒌𝒊𝒏𝒈𝒔 𝒐𝒇 𝒕𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒘𝒆 𝒄𝒂𝒏
𝒈𝒆𝒏𝒆𝒓𝒂𝒕𝒆 𝒕𝒉𝒆 𝒂𝒍𝒈𝒐𝒓𝒊𝒕𝒉𝒎𝒊𝒄 𝒔𝒕𝒓𝒖𝒄𝒕𝒖𝒓𝒆 ∶</h3>
<h3><li>𝑺𝒕𝒆𝒑 𝟏:𝑹𝒆𝒑𝒆𝒂𝒕 𝒖𝒏𝒕𝒊𝒍 𝒆𝒂𝒄𝒉 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓 𝒊𝒏 𝒕𝒉𝒆 𝒊𝒏𝒇𝒊𝒙 𝒏𝒐𝒕𝒂𝒕𝒊𝒐𝒏 𝒊𝒔
𝒔𝒄𝒂𝒏𝒏𝒆𝒅 𝒇𝒓𝒐𝒎 𝒍𝒂𝒔𝒕 𝒕𝒐 𝒇𝒊𝒓𝒔𝒕.</li></h3>
  
<ul>
  
<h3><li> 𝑰𝒇 `)` 𝒊𝒔 𝒆𝒏𝒄𝒐𝒖𝒏𝒕𝒆𝒓𝒆𝒅 𝒑𝒖𝒔𝒉 𝒊𝒕 𝒐𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌.</li></h3>
<h3><li> 𝑰𝒇 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒏𝒅(𝒘𝒉𝒆𝒕𝒉𝒆𝒓 𝒂 𝒅𝒊𝒈𝒊𝒕 𝒐𝒓 𝒂 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓)𝒊𝒔
𝒆𝒏𝒄𝒐𝒖𝒏𝒕𝒆𝒓𝒆𝒅, 𝒂𝒅𝒅 𝒊𝒕 𝒕𝒐 𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</li></h3>
<h3><li> 𝑰𝒇 𝒂 `(` 𝒊𝒔 𝒆𝒏𝒄𝒐𝒖𝒕𝒆𝒓𝒆𝒅 , 𝒕𝒉𝒆𝒏:</li></h3>
  
<ul>
  
<h3>➢ 𝑹𝒆𝒑𝒆𝒂𝒕𝒆𝒅𝒍𝒚 𝒑𝒐𝒑 𝒇𝒓𝒐𝒎 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝒂𝒅𝒅 𝒊𝒕 𝒕𝒐 𝒕𝒉𝒆
𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</h3>
<h3>➢ 𝑫𝒊𝒔𝒄𝒂𝒓𝒅 𝒕𝒉𝒆 ). 𝑻𝒉𝒂𝒕 𝒊𝒔, 𝒓𝒆𝒎𝒐𝒗𝒆 𝒕𝒉𝒆 `)` 𝒇𝒓𝒐𝒎 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌
𝒂𝒏𝒅 𝒅𝒐𝒏𝒐𝒕 𝒂𝒅𝒅 𝒊𝒕 𝒕𝒐 𝒕𝒉𝒆 𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</h3>
  
</ul> 
  
<h3><li> 𝑰𝒇 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒊𝒔 𝒆𝒏𝒄𝒐𝒖𝒏𝒕𝒆𝒓𝒆𝒅 𝒂𝒏𝒅 𝒔𝒕𝒂𝒄𝒌 𝒊𝒔 𝒏𝒐𝒕 𝒆𝒎𝒑𝒕𝒚
𝒂𝒏𝒅 𝒕𝒐𝒑 𝒐𝒇 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒅𝒐𝒆𝒔𝒏𝒐𝒕 𝒄𝒐𝒏𝒕𝒂𝒊𝒏 `)`:</li></h3>
  
<ul>  
  
<h3><li> 𝒂.𝑹𝒆𝒑𝒆𝒂𝒕𝒆𝒅𝒍𝒚 𝒑𝒐𝒑 𝒇𝒓𝒐𝒎 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝒂𝒅𝒅 𝒆𝒂𝒄𝒉 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓
(𝒑𝒐𝒑𝒑𝒆𝒅 𝒇𝒓𝒐𝒎 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌)𝒕𝒐 𝒕𝒉𝒆 𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏
𝒘𝒉𝒊𝒄𝒉 𝒉𝒂𝒔 𝒕𝒉𝒆 𝒔𝒂𝒎𝒆 𝒑𝒓𝒆𝒄𝒆𝒅𝒆𝒏𝒄𝒆 𝒐𝒓
𝒂 𝒉𝒊𝒈𝒉𝒆𝒓 𝒑𝒓𝒆𝒄𝒆𝒅𝒆𝒏𝒄𝒆 .</li></h3>
<h3><li> 𝒃.𝑷𝒖𝒔𝒉 𝒕𝒉𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒕𝒐 𝒕𝒉𝒆 𝑺𝒕𝒂𝒄𝒌.</li></h3>
<h3><li> [𝑬𝑵𝑫 𝑶𝑭 𝑰𝑭]</li></h3>
  
</ul> 
  
<h3>➢ 𝑺𝒕𝒆𝒑 𝟐: 𝑹𝒆𝒑𝒆𝒂𝒕𝒆𝒅𝒍𝒚 𝒑𝒐𝒑 𝒇𝒓𝒐𝒎 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝒂𝒅𝒅 𝒊𝒕 𝒕𝒐
𝒕𝒉𝒆 𝑪𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒖𝒏𝒕𝒊𝒍 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒊𝒔 𝒆𝒎𝒑𝒕𝒚.</h3>
 
<h3>➢ 𝑺𝒕𝒆𝒑 𝟑: 𝑨𝒅𝒅 `\𝟎` 𝒂𝒕 𝒕𝒉𝒆 𝒆𝒏𝒅 𝒐𝒇 𝒕𝒉𝒆 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.
<h3>➢ 𝑺𝒕𝒆𝒑 𝟒: 𝑹𝒆𝒗𝒆𝒓𝒔𝒆 𝒕𝒉𝒆 𝑪𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝑬𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒕𝒐 𝒈𝒆𝒕
𝒑𝒓𝒆𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</h3>
  
<h3><ins>[𝑹𝒆𝒗𝒆𝒓𝒔𝒆 𝒕𝒉𝒆 𝑪𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝑬𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏]</ins></h3>
  
<h3>
  
```Syntax
  
𝒑𝒓𝒆𝒇𝒊𝒙[ ]: 𝒊𝒔 𝒕𝒉𝒆 𝒂𝒓𝒓𝒂𝒚 𝒕𝒉𝒂𝒕 𝒄𝒐𝒏𝒕𝒂𝒊𝒏 𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.
𝑳𝒆𝒏: 𝑳𝒆𝒏𝒈𝒕𝒉 𝒐𝒇 𝒕𝒉𝒆 𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 .
𝑺𝒕𝒂𝒓𝒕: 𝟎 .
𝑬𝒏𝒅: 𝑳𝒆𝒏 − 𝟏.
𝑾𝒉𝒊𝒍𝒆(𝑺𝒕𝒂𝒓𝒕 < 𝑬𝒏𝒅):
 𝒕𝒆𝒎𝒑 ∶= 𝒑𝒓𝒆𝒇𝒊𝒙[𝑺𝒕𝒂𝒓𝒕]
 𝒑𝒓𝒆𝒇𝒊𝒙[𝑺𝒕𝒂𝒓𝒕] ≔ 𝒑𝒓𝒆𝒇𝒊𝒙[𝑬𝒏𝒅]
 𝒑𝒓𝒆𝒇𝒊𝒙[𝑬𝒏𝒅] ≔ 𝒕𝒆𝒎𝒑
 𝑺𝒕𝒂𝒓𝒕 ∶= 𝑺𝒕𝒂𝒓𝒕 + 𝟏
 𝑬𝒏𝒅 ∶= 𝑬𝒏𝒅 − 𝟏
                                
```                                
</h3>  
  
<h3>➢ 𝐒𝐭𝐞𝐩 𝟓:𝐑𝐞𝐭𝐮𝐫𝐧 𝐭𝐡𝐞 𝐩𝐫𝐞𝐟𝐢𝐱 𝐞𝐱𝐩𝐫𝐞𝐬𝐬𝐢𝐨𝒏 𝒂𝒏𝒅 𝒆𝒙𝒊𝒕. </h3> 
  
  
 <h1></h1> 
<h1 align="Center">𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝑨𝒏𝒂𝒍𝒚𝒔𝒊𝒔</h1>  
  
<h3>𝑻𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒂𝒏𝒂𝒍𝒚𝒔𝒊𝒔 𝒐𝒇 𝒕𝒉𝒆 𝒑𝒓𝒐𝒗𝒊𝒅𝒆𝒅 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒄𝒂𝒏
𝒃𝒆 𝒅𝒐𝒏𝒆 𝒃𝒚 𝒄𝒐𝒏𝒔𝒊𝒅𝒆𝒓𝒊𝒏𝒈 𝒕𝒉𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔 𝒑𝒆𝒓𝒇𝒐𝒓𝒎𝒆𝒅
𝒊𝒏 𝒆𝒂𝒄𝒉 𝒍𝒐𝒐𝒑 𝒂𝒏𝒅 𝒄𝒐𝒏𝒅𝒊𝒕𝒊𝒐𝒏𝒂𝒍 𝒔𝒕𝒂𝒕𝒆𝒎𝒆𝒏𝒕.</h3> 
  
<ul>
  
<h3><li> 𝟏. 𝑻𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒔𝒕𝒂𝒓𝒕𝒔 𝒃𝒚 𝒄𝒂𝒍𝒄𝒖𝒍𝒂𝒕𝒊𝒏𝒈 𝒕𝒉𝒆 𝒍𝒆𝒏𝒈𝒕𝒉 𝒐𝒇 𝒕𝒉𝒆 𝒊𝒏𝒑𝒖𝒕 𝒊𝒏𝒇𝒊𝒙
𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏, 𝒘𝒉𝒊𝒄𝒉 𝒕𝒂𝒌𝒆𝒔 𝑶(𝑵) 𝒕𝒊𝒎𝒆, 𝒘𝒉𝒆𝒓𝒆 𝑵 𝒊𝒔 𝒕𝒉𝒆 𝒍𝒆𝒏𝒈𝒕𝒉 𝒐𝒇 𝒕𝒉𝒆
𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</li></h3>
<h3><li> 𝟐. 𝑻𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒕𝒉𝒆𝒏 𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒆𝒔 𝒎𝒆𝒎𝒐𝒓𝒚 𝒇𝒐𝒓 𝒕𝒉𝒆 𝒑𝒓𝒆𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏
𝒖𝒔𝒊𝒏𝒈 𝒎𝒂𝒍𝒍𝒐𝒄, 𝒘𝒉𝒊𝒄𝒉 𝒕𝒂𝒌𝒆𝒔 𝑶(𝑵) 𝒕𝒊𝒎𝒆.</li></h3>
<h3><li> 𝟑. 𝑻𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒄𝒓𝒆𝒂𝒕𝒆𝒔 𝒂 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝒊𝒏𝒊𝒕𝒊𝒂𝒍𝒊𝒛𝒆𝒔 𝒊𝒕, 𝒘𝒉𝒊𝒄𝒉 𝒕𝒂𝒌𝒆𝒔 𝑶(𝑵)
𝒕𝒊𝒎𝒆.</li></h3>
<h3><li> 𝟒. 𝑻𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒆𝒏𝒕𝒆𝒓𝒔 𝒂 𝒘𝒉𝒊𝒍𝒆 𝒍𝒐𝒐𝒑 𝒕𝒉𝒂𝒕 𝒊𝒕𝒆𝒓𝒂𝒕𝒆𝒔 𝑵 𝒕𝒊𝒎𝒆𝒔,
𝒘𝒉𝒆𝒓𝒆 𝑵 𝒊𝒔 𝒕𝒉𝒆 𝒍𝒆𝒏𝒈𝒕𝒉 𝒐𝒇 𝒕𝒉𝒆 𝒊𝒏𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</li></h3>
<h3><li> 𝟓. 𝑰𝒏𝒔𝒊𝒅𝒆 𝒕𝒉𝒆 𝒍𝒐𝒐𝒑, 𝒕𝒉𝒆𝒓𝒆 𝒂𝒓𝒆 𝒔𝒆𝒗𝒆𝒓𝒂𝒍 𝒄𝒐𝒏𝒅𝒊𝒕𝒊𝒐𝒏𝒂𝒍 𝒔𝒕𝒂𝒕𝒆𝒎𝒆𝒏𝒕𝒔 𝒂𝒏𝒅
𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔:</li></h3>
  
<ul>
  
<h3><li>𝒂. 𝑻𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒄𝒉𝒆𝒄𝒌𝒔 𝒊𝒇 𝒕𝒉𝒆 𝒄𝒖𝒓𝒓𝒆𝒏𝒕 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓 𝒊𝒔 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒏𝒅.
𝑻𝒉𝒊𝒔 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒕𝒂𝒌𝒆𝒔 𝒄𝒐𝒏𝒔𝒕𝒂𝒏𝒕 𝒕𝒊𝒎𝒆.</li></h3>
<h3><li>𝒃. 𝑰𝒇 𝒕𝒉𝒆 𝒄𝒖𝒓𝒓𝒆𝒏𝒕 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓 𝒊𝒔 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒏𝒅,𝒊𝒕 𝒊𝒔 𝒂𝒅𝒅𝒆𝒅 𝒕𝒐 𝒕𝒉𝒆 𝒑𝒓𝒆𝒇𝒊𝒙
𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏. 𝑻𝒉𝒊𝒔 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒕𝒂𝒌𝒆𝒔 𝒄𝒐𝒏𝒔𝒕𝒂𝒏𝒕 𝒕𝒊𝒎𝒆.</li></h3>
<h3><li>𝒄. 𝑰𝒇 𝒕𝒉𝒆 𝒄𝒖𝒓𝒓𝒆𝒏𝒕 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓 𝒊𝒔 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓, 𝒕𝒉𝒆𝒓𝒆 𝒂𝒓𝒆 𝒕𝒉𝒓𝒆𝒆 𝒑𝒐𝒔𝒔𝒊𝒃𝒍𝒆
𝒔𝒄𝒆𝒏𝒂𝒓𝒊𝒐𝒔:</li></h3>
  
<ul>
  
<h3><li>𝒊. 𝑰𝒇 𝒕𝒉𝒆 𝒑𝒓𝒆𝒄𝒆𝒅𝒆𝒏𝒄𝒆 𝒐𝒇 𝒕𝒉𝒆 𝒄𝒖𝒓𝒓𝒆𝒏𝒕 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒊𝒔 𝒉𝒊𝒈𝒉𝒆𝒓 𝒕𝒉𝒂𝒏 𝒕𝒉𝒆 𝒕𝒐𝒑
𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒊𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌, 𝒐𝒓 𝒊𝒇 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒊𝒔 𝒆𝒎𝒑𝒕𝒚, 𝒐𝒓 𝒊𝒇 𝒕𝒉𝒆 𝒄𝒖𝒓𝒓𝒆𝒏𝒕
𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒊𝒔 ′)′, 𝒕𝒉𝒆 𝒄𝒖𝒓𝒓𝒆𝒏𝒕 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒊𝒔 𝒑𝒖𝒔𝒉𝒆𝒅 𝒐𝒏𝒕𝒐 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌.
𝑻𝒉𝒆𝒔𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔 𝒕𝒂𝒌𝒆 𝒄𝒐𝒏𝒔𝒕𝒂𝒏𝒕 𝒕𝒊𝒎𝒆 𝒊. 𝒆. 𝑶(𝟏).</li></h3>
<h3><li>𝒊𝒊. 𝑰𝒇 𝒕𝒉𝒆 𝒑𝒓𝒆𝒄𝒆𝒅𝒆𝒏𝒄𝒆 𝒐𝒇 𝒕𝒉𝒆 𝒄𝒖𝒓𝒓𝒆𝒏𝒕 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒊𝒔 𝒍𝒆𝒔𝒔 𝒕𝒉𝒂𝒏
𝒐𝒓 𝒆𝒒𝒖𝒂𝒍 𝒕𝒐 𝒕𝒉𝒆 𝒕𝒐𝒑 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒊𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌, 𝒂𝒏𝒅 𝒕𝒉𝒆 𝒄𝒖𝒓𝒓𝒆𝒏𝒕 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓
𝒊𝒔 ′(′, 𝒕𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒑𝒐𝒑𝒔 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓𝒔 𝒇𝒓𝒐𝒎 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅
𝒂𝒅𝒅𝒔 𝒕𝒉𝒆𝒎 𝒕𝒐 𝒕𝒉𝒆 𝒑𝒓𝒆𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒖𝒏𝒕𝒊𝒍 𝒊𝒕 𝒆𝒏𝒄𝒐𝒖𝒏𝒕𝒆𝒓𝒔 ′)′. 𝑻𝒉𝒆𝒔𝒆
𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔 𝒕𝒂𝒌𝒆 𝒂𝒕 𝒎𝒐𝒔𝒕 𝑶(𝑵)𝒕𝒊𝒎𝒆 𝒊𝒏 𝒕𝒉𝒆 𝒘𝒐𝒓𝒔𝒕 𝒄𝒂𝒔𝒆,
𝒂𝒔 𝒊𝒕 𝒎𝒂𝒚 𝒏𝒆𝒆𝒅 𝒕𝒐 𝒑𝒐𝒑 𝒂𝒍𝒍 𝒕𝒉𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓𝒔 𝒊𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌.</li></h3>
<h3><li>𝒊𝒊𝒊. 𝑭𝒐𝒓 𝒂𝒍𝒍 𝒐𝒕𝒉𝒆𝒓 𝒄𝒂𝒔𝒆𝒔, 𝒕𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒑𝒐𝒑𝒔 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓𝒔 𝒇𝒓𝒐𝒎
𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝒂𝒅𝒅𝒔 𝒕𝒉𝒆𝒎 𝒕𝒐 𝒕𝒉𝒆 𝒑𝒓𝒆𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒖𝒏𝒕𝒊𝒍
𝒕𝒉𝒆 𝒑𝒓𝒆𝒄𝒆𝒅𝒆𝒏𝒄𝒆 𝒐𝒇 𝒕𝒉𝒆 𝒄𝒖𝒓𝒓𝒆𝒏𝒕 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒊𝒔 𝒉𝒊𝒈𝒉𝒆𝒓 𝒕𝒉𝒂𝒏 𝒕𝒉𝒆 𝒕𝒐𝒑
𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒊𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌, 𝒐𝒓 𝒖𝒏𝒕𝒊𝒍 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒊𝒔 𝒆𝒎𝒑𝒕𝒚, 𝒐𝒓
𝒖𝒏𝒕𝒊𝒍 𝒕𝒉𝒆 𝒄𝒖𝒓𝒓𝒆𝒏𝒕 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒊𝒔 ′(′ 𝒐𝒓 ′)′. 𝑻𝒉𝒆𝒔𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔 𝒕𝒂𝒌𝒆
𝒂𝒕 𝒎𝒐𝒔𝒕 𝑶(𝑵) 𝒕𝒊𝒎𝒆 𝒊𝒏 𝒕𝒉𝒆 𝒘𝒐𝒓𝒔𝒕 𝒄𝒂𝒔𝒆.</li></h3>
  
</ul>  
  
</ul>
  
<h3><li>𝟔.𝑨𝒇𝒕𝒆𝒓 𝒕𝒉𝒆 𝒘𝒉𝒊𝒍𝒆 𝒍𝒐𝒐𝒑, 𝒕𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒑𝒐𝒑𝒔 𝒕𝒉𝒆 𝒓𝒆𝒎𝒂𝒊𝒏𝒊𝒏𝒈
𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓𝒔 𝒇𝒓𝒐𝒎 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝒂𝒅𝒅𝒔 𝒕𝒉𝒆𝒎 𝒕𝒐 𝒕𝒉𝒆 𝒑𝒓𝒆𝒇𝒊𝒙
𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.
𝑻𝒉𝒊𝒔 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒕𝒂𝒌𝒆𝒔 𝒂𝒕 𝒎𝒐𝒔𝒕 𝑶(𝑵) 𝒕𝒊𝒎𝒆 𝒊𝒏 𝒕𝒉𝒆 𝒘𝒐𝒓𝒔𝒕 𝒄𝒂𝒔𝒆.</li></h3>
  
<h3><li>𝟕. 𝑻𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒕𝒉𝒆𝒏 𝒓𝒆𝒗𝒆𝒓𝒔𝒆𝒔 𝒕𝒉𝒆 𝒑𝒓𝒆𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒖𝒔𝒊𝒏𝒈 𝒂 𝒘𝒉𝒊𝒍𝒆
𝒍𝒐𝒐𝒑, 𝒘𝒉𝒊𝒄𝒉 𝒕𝒂𝒌𝒆𝒔 𝑶(𝑵) 𝒕𝒊𝒎𝒆.</li></h3>
<h3><li>𝟖. 𝑭𝒊𝒏𝒂𝒍𝒍𝒚, 𝒕𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒇𝒓𝒆𝒆𝒔 𝒕𝒉𝒆 𝒎𝒆𝒎𝒐𝒓𝒚 𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒆𝒅 𝒇𝒐𝒓 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌,
𝒘𝒉𝒊𝒄𝒉 𝒕𝒂𝒌𝒆𝒔 𝒄𝒐𝒏𝒔𝒕𝒂𝒏𝒕 𝒕𝒊𝒎𝒆.</li></h3>
  
<br>  
<h3>𝑶𝒗𝒆𝒓𝒂𝒍𝒍, 𝒕𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝒕𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒊𝒔 𝑶(𝑵),
𝒘𝒉𝒆𝒓𝒆 𝑵 𝒊𝒔 𝒕𝒉𝒆 𝒍𝒆𝒏𝒈𝒕𝒉 𝒐𝒇 𝒕𝒉𝒆 𝒊𝒏𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏. </h3>
  
</ul>  
  
<h3 align="Center"><ins>𝑰𝒏 𝒎𝒐𝒔𝒕 𝒔𝒊𝒎𝒑𝒍𝒊𝒆𝒔𝒕 𝒘𝒐𝒓𝒅𝒔 ∶</ins></h3>
<h3><li>𝑻𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝒑𝒖𝒔𝒉 𝒂𝒏𝒅 𝒑𝒐𝒑 𝒊𝒔 ∶ 𝑶(𝟏) .</li></h3>
<h3><li>𝑾𝒆 𝒕𝒓𝒂𝒗𝒆𝒓𝒔𝒆 𝒊𝒏𝒇𝒊𝒙 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓𝒔 𝒇𝒓𝒐𝒎 𝒍𝒂𝒔𝒕 𝒕𝒐 𝒇𝒊𝒓𝒔𝒕 𝒕𝒂𝒌𝒆𝒔: 𝑶(𝑵).</li></h3>
<h3><li>𝑷𝒐𝒑𝒊𝒏𝒈 𝒐𝒖𝒕 𝒆𝒗𝒆𝒓𝒚𝒕𝒉𝒊𝒏𝒈 𝒇𝒓𝒐𝒎 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝒂𝒅𝒅𝒊𝒏𝒈 𝒊𝒕 𝒕𝒐 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏,
𝒕𝒂𝒌𝒆𝒔 𝑶(𝑵)𝒕𝒊𝒎𝒆,
𝒂𝒏𝒅 𝒓𝒆𝒗𝒆𝒓𝒔𝒊𝒏𝒈 𝒐𝒇 𝒕𝒉𝒆 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒕𝒂𝒌𝒆𝒔 𝑶(𝑵)𝒕𝒊𝒎𝒆, 𝒉𝒆𝒏𝒄𝒆:</li></h3>
  
<ul>
  
<h3><li>𝑰𝒏 𝒂 𝒔𝒖𝒎𝒎𝒂𝒓𝒚 ∶ 𝑶(𝟏) + 𝑶(𝑵) + 𝑶(𝑵) + 𝑶(𝑵) = 𝑶(𝑵)
𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚. 𝑯𝒆𝒏𝒄𝒆 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒊𝒔 𝑶(𝑵).
𝑴𝒐𝒓𝒆 𝒔𝒑𝒆𝒄𝒊𝒇𝒊𝒄𝒂𝒍𝒍𝒚 𝑶(𝑵), 𝒘𝒉𝒆𝒓𝒆 𝑵 𝒊𝒔 𝒕𝒉𝒆 𝒍𝒆𝒏𝒈𝒕𝒉 𝒐𝒇 𝒕𝒉𝒆
𝒊𝒏𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</li></h3>
  
  
![Screenshot (658)](https://github.com/AvinandanBose/Infix_Prefix-Space_Time_Complexity/assets/38869235/8f14b797-e279-4f96-a1da-8186cba72270)
  
  
  

</ul>  
  
 <h1></h1> 
<h1 align="Center">𝑺𝒑𝒂𝒄𝒆  𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝑨𝒏𝒂𝒍𝒚𝒔𝒊𝒔</h1> 
  
<ul>
  
<h3><li>𝑻𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒆𝒔 𝒎𝒆𝒎𝒐𝒓𝒚 𝒇𝒐𝒓 𝒕𝒉𝒆 𝒑𝒓𝒆𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏
𝒖𝒔𝒊𝒏𝒈 𝒎𝒂𝒍𝒍𝒐𝒄. 𝑻𝒉𝒆 𝒂𝒎𝒐𝒖𝒏𝒕 𝒐𝒇 𝒎𝒆𝒎𝒐𝒓𝒚 𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒆𝒅 𝒊𝒔 (𝒍𝒆𝒏)
∗ 𝒔𝒊𝒛𝒆𝒐𝒇(𝒄𝒉𝒂𝒓), 𝒘𝒉𝒆𝒓𝒆 𝒍𝒆𝒏 𝒊𝒔 𝒕𝒉𝒆 𝒍𝒆𝒏𝒈𝒕𝒉 𝒐𝒇 𝒕𝒉𝒆 𝒊𝒏𝒇𝒊𝒙
𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏. 𝑻𝒉𝒆𝒓𝒆𝒇𝒐𝒓𝒆, 𝒕𝒉𝒆 𝒔𝒑𝒂𝒄𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒇𝒐𝒓 𝒕𝒉𝒆
𝒑𝒓𝒆𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒊𝒔 𝑶(𝑵), 𝒘𝒉𝒆𝒓𝒆 𝑵 𝒊𝒔 𝒕𝒉𝒆 𝒍𝒆𝒏𝒈𝒕𝒉 𝒐𝒇 𝒕𝒉𝒆
𝒊𝒏𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</li></h3>
  
<h3><li>𝑻𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒄𝒓𝒆𝒂𝒕𝒆𝒔 𝒂 𝒔𝒕𝒂𝒄𝒌 𝒐𝒇 𝒔𝒊𝒛𝒆 𝒍𝒆𝒏 𝒖𝒔𝒊𝒏𝒈 𝒕𝒉𝒆
𝒄𝒓𝒆𝒂𝒕𝒆()𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏. 𝑻𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒓𝒆𝒒𝒖𝒊𝒓𝒆𝒔 𝒔𝒑𝒂𝒄𝒆 𝒕𝒐 𝒔𝒕𝒐𝒓𝒆
𝒕𝒉𝒆 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓𝒔 𝒊𝒏 𝒕𝒉𝒆 𝒊𝒏𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.
𝑻𝒉𝒆𝒓𝒆𝒇𝒐𝒓𝒆, 𝒕𝒉𝒆 𝒔𝒑𝒂𝒄𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒇𝒐𝒓 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒊𝒔 𝒂𝒍𝒔𝒐 𝑶(𝑵).</li></h3>
  
<h3><li>𝑻𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒖𝒔𝒆𝒔 𝒂 𝒇𝒆𝒘 𝒂𝒅𝒅𝒊𝒕𝒊𝒐𝒏𝒂𝒍 𝒗𝒂𝒓𝒊𝒂𝒃𝒍𝒆𝒔
𝒔𝒖𝒄𝒉 𝒂𝒔 𝒍𝒆𝒏,𝒊,𝒋, 𝒔𝒕𝒂𝒓𝒕, 𝒆𝒏𝒅, 𝒂𝒏𝒅 𝒕𝒆𝒎𝒑, 𝒘𝒉𝒊𝒄𝒉 𝒓𝒆𝒒𝒖𝒊𝒓𝒆 𝒄𝒐𝒏𝒔𝒕𝒂𝒏𝒕 𝒔𝒑𝒂𝒄𝒆.
𝑨𝒏𝒅 𝒕𝒉𝒆 𝒑𝒖𝒔𝒉 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒉𝒂𝒑𝒑𝒆𝒏𝒔 `𝑵` 𝒕𝒊𝒎𝒆𝒔 𝒊𝒏 𝒔𝒕𝒂𝒄𝒌 𝒕𝒂𝒌𝒊𝒏𝒈
𝑶(𝑵) 𝒔𝒑𝒂𝒄𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚.</li></h3>
  
<h3><li>𝑾𝒉𝒆𝒓𝒆 𝒂𝒔 𝒕𝒉𝒆 𝒂𝒅𝒅𝒊𝒏𝒈 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒕𝒐 𝒑𝒓𝒆𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒂𝒏𝒅
𝒔𝒘𝒂𝒑𝒑𝒊𝒏𝒈 𝒐𝒇 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒂𝒏𝒅 𝒓𝒆𝒗𝒆𝒓𝒔𝒊𝒏𝒈 𝒕𝒉𝒆 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒕𝒂𝒌𝒆𝒔
𝒂 𝒄𝒐𝒏𝒔𝒕𝒂𝒏𝒕 𝒂𝒎𝒐𝒖𝒏𝒕 𝒐𝒇 𝒔𝒑𝒂𝒄𝒆 𝒊. 𝒆. 𝑶(𝟏).</li></h3>

  <h3><li>𝑰𝒇 𝒘𝒆 𝒇𝒐𝒄𝒖𝒔 𝒐𝒏𝒍𝒚 𝒐𝒏 𝒕𝒉𝒆 𝒔𝒑𝒂𝒄𝒆 𝒕𝒂𝒌𝒆𝒏 𝒅𝒖𝒓𝒊𝒏𝒈 𝒕𝒉𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏
, 𝒕𝒉𝒆𝒏 𝒘𝒆 𝒐𝒏𝒍𝒚 𝒉𝒂𝒗𝒆 𝒕𝒉𝒆 𝑷𝒖𝒔𝒉 𝒂𝒏𝒅 𝑨𝒓𝒓𝒂𝒚 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒊. 𝒆.
𝑶(𝑵) + 𝑶(𝟏) = 𝑶(𝑵) .
𝑯𝒆𝒏𝒄𝒆 𝒔𝒑𝒂𝒄𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒊𝒔 𝑶(𝑵).</li></h3>  
  
</ul>  
  
  
<h2> </h2>
<h1> 👉 <a href="https://github.com/AvinandanBose/CPLUSPLUS_DataStructure"> 𝑪++ - 𝑰𝒏𝒇𝒊𝒙 𝒕𝒐 𝑷𝒓𝒆𝒇𝒊𝒙 𝑪𝒐𝒏𝒗𝒆𝒓𝒔𝒊𝒐𝒏 </a> </h1>  
  
